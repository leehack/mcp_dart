import 'dart:async';
import 'dart:io';

import 'package:build/build.dart';
import 'package:mason/mason.dart';
import 'package:path/path.dart' as p;

class MasonBundleBuilder implements Builder {
  @override
  final buildExtensions = const {
    'brick.yaml': ['brick.bundle.dart'],
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    final inputId = buildStep.inputId;

    // Calculate the directory of the brick from the input file
    // The input file is likely .../brick.yaml
    // We need the directory containing it to pass to createBundle.

    // Note: build_runner usually works with Assets.
    // Accessing the filesystem via `File` is technically frowned upon for hermetic builds,
    // but for this local CLI generation task, it is the most pragmatic way to interface
    // with `mason.createBundle` which expects a Directory.
    // Ensure we are working with correct paths.

    final packagePath = p.absolute('.'); // Assuming running from package root
    final brickDir = p.dirname(p.join(packagePath, inputId.path));

    log.info('Bundling brick at $brickDir');

    final bundle = createBundle(Directory(brickDir));
    final bundleJson = bundle.toJson();

    final outputId = inputId.changeExtension('.bundle.dart');
    // Convert snake_case or whatever to camelCase + Bundle
    final bundleName = bundle.name;
    final varName = '${_toCamelCase(bundleName)}Bundle';

    final content = '''
// Generated by MasonBundleBuilder
import 'package:mason/mason.dart';

final $varName = MasonBundle.fromJson(${_jsonToDart(bundleJson)});
''';

    await buildStep.writeAsString(outputId, content);
  }

  String _toCamelCase(String input) {
    if (!input.contains('_')) return input;
    return input
        .split('_')
        .asMap()
        .map((i, w) {
          if (i == 0) return MapEntry(i, w);
          if (w.isEmpty) return MapEntry(i, w);
          return MapEntry(i, w[0].toUpperCase() + w.substring(1));
        })
        .values
        .join('');
  }

  String _jsonToDart(Map<String, dynamic> json) {
    final buffer = StringBuffer();
    _writeMap(buffer, json);
    return buffer.toString();
  }

  void _writeMap(StringBuffer buffer, Map<String, dynamic> map) {
    buffer.write('{');
    map.forEach((key, value) {
      buffer.write("'$key': ");
      _writeValue(buffer, value);
      buffer.write(', ');
    });
    buffer.write('}');
  }

  void _writeValue(StringBuffer buffer, dynamic value) {
    if (value is String) {
      if (value.contains('\n')) {
        buffer.write("'''${value.replaceAll("'''", "\\'''")}'''");
      } else {
        buffer.write("'${value.replaceAll("'", "\\'")}'");
      }
    } else if (value is num || value is bool || value == null) {
      buffer.write(value);
    } else if (value is List) {
      buffer.write('[');
      for (var item in value) {
        _writeValue(buffer, item);
        buffer.write(', ');
      }
      buffer.write(']');
    } else if (value is Map) {
      _writeMap(buffer, value as Map<String, dynamic>);
    }
  }
}

Builder masonBundleBuilder(BuilderOptions options) => MasonBundleBuilder();
